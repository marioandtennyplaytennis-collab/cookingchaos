<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cooking Chaos: Full Restaurant Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Using Comic Sans MS, a common system font, and keeping Bangers for titles -->
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-primary: #f59e0b; /* Orange/Yellow */
            --color-secondary: #dc2626; /* Red */
            --color-kitchen: #e5e7eb; /* Light Gray for workspace */
            --color-counter: #78350f; /* Dark Wood Brown */
            --color-floor: #fef3c7; /* Creamy Floor */
        }
        body {
            /* Changed font to Comic Sans MS */
            font-family: 'Comic Sans MS', 'Comic Sans', cursive, sans-serif;
            background-color: #3f3f46;
        }
        .game-screen {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }
        .game-board {
            /* Changed font to Comic Sans MS */
            font-family: 'Comic Sans MS', 'Comic Sans', cursive, sans-serif;
            width: 100%;
            max-width: 1200px;
            height: 80vh; /* Fixed height for video game feel */
            min-height: 600px;
            background-color: var(--color-floor);
            border: 8px solid var(--color-counter);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: grid;
            grid-template-rows: 15% 70% 15%; /* Top (Customers) | Center (Kitchen) | Bottom (Actions) */
        }

        .game-title {
            font-family: 'Bangers', cursive;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0px var(--color-secondary);
        }

        /* --- Customer Area --- */
        .customer-area {
            background: repeating-linear-gradient(45deg, #fef08a, #fef08a 10px, #fde68a 10px, #fde68a 20px);
            border-bottom: 4px solid var(--color-counter);
        }
        .customer-slot {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 5px;
            position: relative;
        }
        .customer-icon {
            font-size: 2.5rem;
            transition: transform 0.2s, opacity 0.2s;
            cursor: pointer;
        }
        .customer-angry {
            animation: shake 0.5s infinite;
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); } 20% { transform: translate(-1px, -2px) rotate(-1deg); } 40% { transform: translate(-3px, 0px) rotate(1deg); } 60% { transform: translate(3px, 2px) rotate(0deg); } 80% { transform: translate(1px, -1px) rotate(1deg); } 100% { transform: translate(-1px, 2px) rotate(-1deg); }
        }
        .customer-order-tag {
            background-color: white;
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            white-space: nowrap;
            font-size: 0.7rem;
            font-weight: 700;
            position: absolute;
            top: 5px;
        }

        /* --- Kitchen & Pass Area --- */
        .kitchen-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 0.3fr; /* Prep/Cooking | Pass */
        }
        .prep-area, .cooking-area {
            border: 4px solid var(--color-counter);
            background-color: var(--color-kitchen);
            padding: 10px;
            position: relative;
        }
        .prep-area { border-right: none; }

        .item-slot {
            background-color: white;
            padding: 8px;
            border-radius: 6px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            transition: border-color 0.3s;
        }
        /* Removed mouse-spoilage-item class and its animation */

        /* --- The Pass (Serving Area) --- */
        .the-pass {
            grid-column: 1 / span 2;
            background-color: var(--color-counter);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            padding: 10px;
        }
        .pass-label {
            font-family: 'Bangers', cursive;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
            font-size: 1.5rem;
            margin-right: 15px;
        }
        .plated-dish {
            background-color: #fca5a5; /* Plate color */
            border: 2px dashed #ef4444;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .plated-dish:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* Utility classes */
        .progress-bar { height: 6px; background-color: #e5e7eb; border-radius: 9999px; overflow: hidden; }
        .progress-fill { height: 100%; transition: width 0.1s linear; }
        .btn-game { font-family: 'Bangers', cursive; letter-spacing: 1px; }
    </style>
</head>
<body class="selection:bg-yellow-300 selection:text-gray-900">

    <div id="game-container" class="game-screen">
        <div id="game-over-screen" class="hidden absolute inset-0 z-50 bg-gray-900 bg-opacity-95 flex items-center justify-center p-4">
            <!-- Game Over Content Renders Here -->
        </div>

        <div class="game-board rounded-2xl">
            <!-- HEADER AND STATS -->
            <div class="flex justify-between items-center p-3 bg-gray-900 text-white">
                <h1 class="text-3xl game-title text-yellow-500">COOKING CHAOS DINER</h1>
                <div class="flex items-center space-x-4 text-sm font-semibold">
                    <span id="game-time" class="p-1 px-3 rounded bg-gray-700">Time: 00:00</span>
                    <span id="money-count" class="p-1 px-3 rounded bg-green-600">Money: $0</span>
                    <span id="mice-count" class="p-1 px-3 rounded bg-red-600">Mice Eaten: 0</span>
                    <span id="game-status" class="p-1 px-3 rounded bg-blue-500">Status: Normal</span>
                </div>
            </div>

            <!-- MAIN RESTAURANT LAYOUT -->
            <div class="grid grid-cols-4 h-full">
                <!-- 1. Customer Counter/Seating Area (Col 1-2) -->
                <div id="customer-counter" class="col-span-2 customer-area grid grid-cols-4 gap-2 p-2 border-r-4 border-l-4 border-counter">
                    <!-- 4 customer slots -->
                    <div id="slot-1" class="customer-slot"></div>
                    <div id="slot-2" class="customer-slot"></div>
                    <div id="slot-3" class="customer-slot"></div>
                    <div id="slot-4" class="customer-slot"></div>
                </div>

                <!-- 2. Kitchen Area (Col 3-4, full height) -->
                <div class="col-span-2 kitchen-grid">
                    <!-- Prep Area (Top Left of Kitchen) -->
                    <div class="prep-area">
                        <h2 class="text-lg font-bold mb-2 text-gray-800">üî™ Prep Counter (Mouse Risk)</h2>
                        <div id="counter-ingredients" class="grid grid-cols-2 gap-2 h-[85%] overflow-y-auto">
                            <p id="counter-placeholder" class="text-gray-500 text-sm col-span-2 self-center text-center">Place ingredients here to prep.</p>
                        </div>
                    </div>
                    
                    <!-- Cooking Area (Top Right of Kitchen) -->
                    <div class="cooking-area">
                        <h2 class="text-lg font-bold mb-2 text-gray-800">üî• Cooking Stations</h2>
                        <div id="cooking-station" class="grid grid-cols-1 gap-3 h-[85%] overflow-y-auto">
                            <p class="text-gray-500 text-sm italic">Start a recipe to use a station.</p>
                        </div>
                    </div>
                    
                    <!-- The Pass / Serving Area (Bottom of Kitchen) -->
                    <div id="the-pass" class="the-pass">
                        <span class="pass-label">THE PASS:</span>
                        <div id="plated-dishes" class="flex flex-wrap gap-3">
                             <p class="text-yellow-200 text-sm">Plated food goes here...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ACTION BAR (BOTTOM) -->
            <div id="action-bar" class="bg-gray-800 p-3 flex justify-between items-center border-t-4 border-yellow-500">
                <div id="inventory-display" class="flex flex-wrap gap-2 text-sm text-white">
                    <p class="text-gray-400">Inventory: Empty</p>
                </div>
                
                <div id="action-buttons" class="flex flex-wrap justify-end gap-3">
                    <button id="stockroom-btn" onclick="goToStockroom()" class="btn-game bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-150 shadow-lg">
                        üì¶ Stockroom
                    </button>
                    <button id="recipe-modal-btn" onclick="showRecipeModal()" class="btn-game bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition duration-150 shadow-lg">
                        üçΩÔ∏è Recipes
                    </button>
                </div>
            </div>

        </div>
    </div>
    
    <!-- Modals (Hidden by default) -->
    <!-- Stockroom Modal (Remains the same structure) -->
    <div id="stockroom-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-xl p-6 w-full max-w-lg shadow-2xl">
            <h2 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2 game-title">Stockroom üì¶ (Buy & Gather)</h2>
            <div id="stockroom-inventory" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6 max-h-96 overflow-y-auto pr-2">
                <!-- Stockroom items will be rendered here -->
            </div>
            <p class="text-sm text-gray-600 mb-4">Gathering costs time. Buying costs money.</p>
            <button onclick="closeStockroomModal()" class="btn-game bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Exit Stockroom
            </button>
        </div>
    </div>

    <!-- Recipe Modal (Remains the same structure) -->
    <div id="recipe-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-xl p-6 w-full max-w-lg shadow-2xl">
            <h2 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2 game-title">Recipes üçΩÔ∏è</h2>
            <div id="recipes-list" class="space-y-4 max-h-96 overflow-y-auto pr-2 mb-6">
                <!-- Recipes will be rendered here -->
            </div>
            <button onclick="closeRecipeModal()" class="btn-game bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Close
            </button>
        </div>
    </div>
    
    <!-- Custom Modal for Alerts/Messages (Handles the no-alert rule) -->
    <div id="custom-message-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div id="custom-message-content" class="bg-white rounded-xl p-6 w-full max-w-sm shadow-2xl text-center">
            <!-- Content filled by alertMessage() -->
        </div>
    </div>


<script>
    // --- Configuration and Initial State ---

    const GAME_DURATION_SECS = 600; // 10 minutes (600 game ticks)
    const LUNCH_RUSH_START_SECS = 120; // 2:00
    const LUNCH_RUSH_END_SECS = 480; // 8:00
    const STOCKROOM_TIME_COST = 20; // Seconds deducted for a stockroom trip
    const MOUSE_SPOILAGE_TIME = 30; // Seconds until a counter ingredient is eaten
    const INITIAL_STOCK_COUNT = 5; // Initial stock of each ingredient
    const MAX_CUSTOMER_SLOTS = 4; // Number of visual customer spots
    
    // Base frequency (1 / orderFrequency) for new customers in seconds
    const BASE_ORDER_FREQUENCY = 30; 
    // 30% slower means multiplying the time by (1 / (1 - 0.30)) = 1.4286
    const SLOW_FACTOR = 1.4286; 

    // --- Game Data ---

    const RECIPES = [
        { id: 'burger', name: 'Classic Burger üçî', price: 15, time: 25, ingredients: ['bun', 'patty', 'lettuce'], exp: 5 },
        { id: 'fries', name: 'Fries üçü', price: 8, time: 15, ingredients: ['potatoes'], exp: 2 },
        { id: 'salad', name: 'Garden Salad ü•ó', price: 12, time: 20, ingredients: ['lettuce', 'tomato', 'onion'], exp: 4 },
        { id: 'pasta', name: 'Pasta Primavera üçù', price: 20, time: 35, ingredients: ['pasta', 'tomato', 'onion'], exp: 7 },
        { id: 'steak', name: 'Grilled Steak ü•©', price: 30, time: 40, ingredients: ['patty', 'potatoes'], exp: 10 },
    ];
    
    const STOCKROOM_ITEMS = [
        { name: 'bun', label: 'Buns', time: 5, cost: 5 },
        { name: 'patty', label: 'Patties (Raw)', time: 8, cost: 10 },
        { name: 'lettuce', label: 'Lettuce', time: 4, cost: 3 },
        { name: 'tomato', label: 'Tomatoes', time: 5, cost: 4 },
        { name: 'onion', label: 'Onions', time: 5, cost: 3 },
        { name: 'potatoes', label: 'Potatoes', time: 7, cost: 6 },
        { name: 'pasta', label: 'Pasta', time: 5, cost: 8 },
    ];

    const CUSTOMER_EMOJIS = ['üßë', 'üë©', 'üë¥', 'üëµ', 'üë®‚Äçü¶±', 'üë±‚Äç‚ôÄÔ∏è', 'üë≤', 'üßï'];


    // --- State Initialization ---
    let state = {
        time: 0,
        money: 0,
        inventory: {}, // ingredientName: count (what you are carrying)
        stockroomStock: {}, // ingredientName: count (what is in the stockroom)
        // Counter Ingredients now include a 'warned' flag for one-time alerts
        counterIngredients: [], // { id: 'uuid', name: 'patty', spoilageTimer: 30, warned: false }
        cooking: [], // { id: 'uuid', recipeId: 'burger', cookTimer: 25, maxTime: 25, quality: 0 }
        customers: [], // { orderId: 1, recipeId: 'burger', timer: 60, maxTime: 60, emoji: 'üßë', slot: 1 }
        dishes: [], // { id: 'uuid', recipeId: 'burger', quality: 0.8 }
        nextCustomerId: 1,
        
        // Stats for Ranking
        miceEaten: 0,
        customersServed: 0,
        servedEarlyBonus: 0,
        totalQualityScore: 0,
        angryCustomers: 0,
        gameRunning: true,
        gameInterval: null,
    };

    // --- DOM Elements ---
    const elements = {
        gameTime: document.getElementById('game-time'),
        gameStatus: document.getElementById('game-status'),
        miceCount: document.getElementById('mice-count'),
        moneyCount: document.getElementById('money-count'),
        customerCounter: document.getElementById('customer-counter'),
        counterIngredients: document.getElementById('counter-ingredients'),
        cookingStation: document.getElementById('cooking-station'),
        inventoryDisplay: document.getElementById('inventory-display'),
        stockroomModal: document.getElementById('stockroom-modal'),
        stockroomInventory: document.getElementById('stockroom-inventory'),
        recipeModal: document.getElementById('recipe-modal'),
        recipesList: document.getElementById('recipes-list'),
        gameOverScreen: document.getElementById('game-over-screen'),
        counterPlaceholder: document.getElementById('counter-placeholder'),
        platedDishes: document.getElementById('plated-dishes'),
        customMessageModal: document.getElementById('custom-message-modal'),
        customMessageContent: document.getElementById('custom-message-content'),
    };

    // --- Utility Functions ---
    const formatTime = (seconds) => {
        const min = Math.floor(seconds / 60).toString().padStart(2, '0');
        const sec = (seconds % 60).toString().padStart(2, '0');
        return `${min}:${sec}`;
    };

    const getRecipe = (id) => RECIPES.find(r => r.id === id);
    const uuid = () => crypto.randomUUID();
    
    /**
     * Closes the custom message modal.
     * This function is globally accessible and used by the inline onclick handler, 
     * resolving the 'modal is not defined' error.
     */
    function closeMessageModal() {
        elements.customMessageModal.classList.add('hidden');
    }


    // --- Game Logic: Update State ---

    function isLunchRush() {
        return state.time >= LUNCH_RUSH_START_SECS && state.time < LUNCH_RUSH_END_SECS;
    }

    function updateGameStatus() {
        const rush = isLunchRush();
        if (rush) {
            elements.gameStatus.textContent = 'RUSH ACTIVE! üî•';
            elements.gameStatus.className = 'p-1 px-3 rounded bg-red-600 transition duration-300';
            elements.gameTime.textContent = `Time: ${formatTime(state.time)} (RUSH!)`;
        } else if (state.time >= GAME_DURATION_SECS) {
            elements.gameStatus.textContent = 'CLOSED! üîî';
            elements.gameStatus.className = 'p-1 px-3 rounded bg-gray-700 transition duration-300';
        } else {
            elements.gameStatus.textContent = 'Status: Normal';
            elements.gameStatus.className = 'p-1 px-3 rounded bg-blue-500 transition duration-300';
            elements.gameTime.textContent = `Time: ${formatTime(state.time)}`;
        }
    }
    
    // Finds the first available slot (1 to MAX_CUSTOMER_SLOTS)
    function findAvailableSlot() {
        const usedSlots = state.customers.map(c => c.slot);
        for (let i = 1; i <= MAX_CUSTOMER_SLOTS; i++) {
            if (!usedSlots.includes(i)) {
                return i;
            }
        }
        return null; // Restaurant is full
    }
    
    // Spoilage (Mice) Logic
    function updateSpoilage() {
        let needsRender = false;

        if (!state.counterIngredients.length) {
            elements.counterPlaceholder.classList.remove('hidden');
        } else {
            elements.counterPlaceholder.classList.add('hidden');
        }

        const newCounterIngredients = [];
        let spoiledThisTick = 0;

        for (const item of state.counterIngredients) {
            item.spoilageTimer -= 1;
            
            // --- One-time Mouse Warning Logic ---
            if (item.spoilageTimer === 10 && !item.warned) {
                 alertMessage("Mouse Attack Warning!", `A mouse is approaching the ${item.name}! It will spoil in ${item.spoilageTimer}s!`, 'red');
                 item.warned = true;
                 needsRender = true;
            }
            // --- End Warning Logic ---

            if (item.spoilageTimer <= 0) {
                state.miceEaten += 1;
                spoiledThisTick += 1;
                needsRender = true;
            } else {
                newCounterIngredients.push(item);
                if (item.spoilageTimer === 10) needsRender = true; // Rerender when border changes
            }
        }
        state.counterIngredients = newCounterIngredients;
        if (needsRender || spoiledThisTick > 0) renderCounterIngredients();
    }

    // Customer & Order Logic
    function updateCustomers() {
        const timerRate = isLunchRush() ? 1.25 : 1;
        const newCustomers = [];
        let angryThisTick = false;

        for (const customer of state.customers) {
            customer.timer -= 1 * timerRate;
            if (customer.timer <= 0) {
                // Customer gets angry and leaves
                state.angryCustomers += 1;
                angryThisTick = true;
            } else {
                newCustomers.push(customer);
            }
        }
        state.customers = newCustomers;
        if (angryThisTick || state.customers.length !== newCustomers.length) {
            renderCustomers(); 
        }
        
        // Randomly generate new order if slots are free
        const slotsFree = MAX_CUSTOMER_SLOTS - state.customers.length;
        if (slotsFree > 0 && state.time < GAME_DURATION_SECS) {
            // Determine base frequency (lower number = more frequent)
            const baseFrequency = BASE_ORDER_FREQUENCY; 
            
            // Adjust frequency based on rush hour, then apply the slow factor
            let orderFrequency = isLunchRush() ? baseFrequency * 0.5 : baseFrequency;
            orderFrequency = orderFrequency * SLOW_FACTOR; // Slower order rate

            if (Math.random() < (1 / orderFrequency)) {
                generateNewOrder();
            }
        }
    }

    function generateNewOrder() {
        const slot = findAvailableSlot();
        if (!slot) return; // Cannot take order if no slot is free
        
        const recipe = RECIPES[Math.floor(Math.random() * RECIPES.length)];
        const maxTime = Math.max(70 - state.time / 10, 40); 
        
        state.customers.push({
            orderId: state.nextCustomerId++,
            recipeId: recipe.id,
            recipeName: recipe.name,
            timer: maxTime,
            maxTime: maxTime,
            emoji: CUSTOMER_EMOJIS[Math.floor(Math.random() * CUSTOMER_EMOJIS.length)],
            slot: slot,
        });
        renderCustomers();
    }

    // Cooking Logic
    function updateCooking() {
        state.cooking.forEach(dish => {
            dish.cookTimer -= 1;
            
            const timePassed = dish.maxTime - dish.cookTimer;
            const idealTime = dish.maxTime / 2;
            
            if (timePassed <= idealTime) {
                dish.quality = timePassed / idealTime;
            } else if (dish.cookTimer > 0) {
                dish.quality = 1.0 - (timePassed - idealTime) / idealTime;
            } else {
                dish.quality = 0.0;
            }
        });

        const newCooking = state.cooking.filter(dish => dish.cookTimer > -10); 
        if (newCooking.length !== state.cooking.length) {
            state.cooking = newCooking;
        }
        renderCookingStation();
    }

    // --- Game Loop ---
    function gameTick() {
        if (!state.gameRunning) return;

        state.time += 1;
        
        updateGameStatus();
        updateSpoilage();
        updateCustomers();
        updateCooking();

        elements.miceCount.textContent = state.miceEaten;
        elements.moneyCount.textContent = state.money;
        
        // End Game Condition
        if (state.time >= GAME_DURATION_SECS) {
            endGame();
        }
    }

    function startGame() {
        // Initial setup
        state.time = 0;
        state.money = 100;
        state.inventory = {};
        state.miceEaten = 0;
        state.customersServed = 0;
        state.servedEarlyBonus = 0;
        state.totalQualityScore = 0;
        state.angryCustomers = 0;
        state.dishes = [];
        state.customers = [];
        state.cooking = [];
        state.counterIngredients = [];
        state.gameRunning = true;
        
        state.stockroomStock = STOCKROOM_ITEMS.reduce((acc, item) => {
            acc[item.name] = INITIAL_STOCK_COUNT;
            return acc;
        }, {});
        
        // Initial renderings
        renderInventory();
        renderCustomers();
        renderCookingStation();
        renderCounterIngredients();
        renderPlatedDishes();
        
        // Start the game loop (1 tick per second)
        state.gameInterval = setInterval(gameTick, 1000);
        
        // Initial orders
        generateNewOrder();
        generateNewOrder();
    }

    function endGame() {
        clearInterval(state.gameInterval);
        state.gameRunning = false;
        
        const totalCustomers = state.customersServed + state.angryCustomers;
        const averageQuality = state.customersServed > 0 ? state.totalQualityScore / state.customersServed : 0;
        
        let rankScore = state.money; 
        rankScore += state.servedEarlyBonus * 10;
        rankScore += averageQuality * 100;
        rankScore -= state.miceEaten * 50;
        rankScore -= state.angryCustomers * 75;

        const rank = getRank(rankScore);

        const html = `
            <div class="bg-white rounded-2xl p-8 w-full max-w-lg shadow-2xl text-gray-800 text-center transform scale-100 transition-all duration-300">
                <h2 class="text-4xl font-extrabold mb-4 text-gray-800 game-title">CLOSING TIME!</h2>
                <p class="text-xl mb-6">Your Final Performance</p>
                
                <div class="space-y-3 mb-8 text-left">
                    <p class="flex justify-between items-center text-lg font-medium"><span class="text-gray-600">Money Earned:</span> <span class="text-green-600 font-bold">$${state.money}</span></p>
                    <p class="flex justify-between items-center text-lg font-medium"><span class="text-gray-600">Customers Served:</span> <span class="font-bold">${state.customersServed} / ${totalCustomers}</span></p>
                    <p class="flex justify-between items-center text-lg font-medium"><span class="text-gray-600">Early Service Bonus:</span> <span class="text-blue-600 font-bold">${state.servedEarlyBonus}s</span></p>
                    <p class="flex justify-between items-center text-lg font-medium"><span class="text-gray-600">Avg. Quality:</span> <span class="font-bold">${(averageQuality * 100).toFixed(0)}%</span></p>
                    <hr class="border-gray-300">
                    <p class="flex justify-between items-center text-lg font-medium"><span class="text-red-600">Mice/Spoilage Penalty:</span> <span class="font-bold">${state.miceEaten}</span></p>
                    <p class="flex justify-between items-center text-lg font-medium"><span class="text-red-600">Angry Customers:</span> <span class="font-bold">${state.angryCustomers}</span></p>
                </div>

                <div class="bg-yellow-100 p-4 rounded-xl border-4 border-yellow-400">
                    <p class="text-2xl font-bold mb-2">Your Final Rank: ${rank.label} ${rank.icon}</p>
                    <p class="text-sm text-gray-700">Rank Score: ${rankScore.toFixed(0)}</p>
                </div>

                <button onclick="window.location.reload()" class="mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-150 w-full shadow-lg btn-game">
                    Play Again
                </button>
            </div>
        `;
        elements.gameOverScreen.innerHTML = html;
        elements.gameOverScreen.classList.remove('hidden');
    }

    function getRank(score) {
        if (score > 1000) return { label: 'Culinary Master', icon: 'üëë' };
        if (score > 500) return { label: 'Head Chef', icon: 'üåü' };
        if (score > 200) return { label: 'Line Cook', icon: 'üë®‚Äçüç≥' };
        if (score > 0) return { label: 'Kitchen Porter', icon: 'üßπ' };
        return { label: 'Dish Washer', icon: 'üóëÔ∏è' };
    }


    // --- Interaction Functions ---
    function goToStockroom() {
        if (!state.gameRunning) return;
        state.time += STOCKROOM_TIME_COST;
        renderStockroomModal();
        elements.stockroomModal.classList.remove('hidden');
    }
    
    function closeStockroomModal() {
        elements.stockroomModal.classList.add('hidden');
    }
    
    function buyStock(name, cost) {
        if (!state.gameRunning) return;
        if (state.money < cost) {
            alertMessage("Cannot Buy!", `You need $${cost} to buy more ${name}.`, 'red');
            return;
        }

        state.money -= cost;
        state.stockroomStock[name] = (state.stockroomStock[name] || 0) + 1;

        renderStockroomModal();
        alertMessage("Stock Purchased", `Bought 1 ${name} for $${cost}.`, 'blue');
    }

    function gatherIngredient(name, timeCost) {
        if (!state.gameRunning) return;
        if (state.stockroomStock[name] <= 0) {
             alertMessage("Stock Empty!", `The stockroom is out of ${name}. Buy more stock.`, 'red');
             return;
        }

        state.time += timeCost;
        state.stockroomStock[name] -= 1; 

        state.inventory[name] = (state.inventory[name] || 0) + 1;
        renderInventory();
        renderStockroomModal(); 
        alertMessage("Ingredient Gathered", `1 ${name} added to inventory.`, 'green');
    }

    function placeIngredientOnCounter(name) {
        if (!state.gameRunning) return;
        if (state.inventory[name] <= 0) return;

        state.inventory[name] -= 1;
        state.counterIngredients.push({
            id: uuid(),
            name: name,
            spoilageTimer: MOUSE_SPOILAGE_TIME,
            warned: false, // New flag: Has the one-time warning been triggered?
        });

        renderInventory();
        renderCounterIngredients();
        alertMessage("Placed Ingredient", `${name} is on the counter. Watch out for mice!`, 'yellow');
    }
    
    function removeIngredientFromCounter(itemId) {
        if (!state.gameRunning) return;
        const index = state.counterIngredients.findIndex(item => item.id === itemId);
        const item = state.counterIngredients[index];
        if (!item) return;

        state.inventory[item.name] = (state.inventory[item.name] || 0) + 1;
        state.counterIngredients.splice(index, 1);
        
        renderInventory();
        renderCounterIngredients();
        alertMessage("Item Secured", `${item.name} put back in inventory.`, 'blue');
    }

    function showRecipeModal() {
        if (!state.gameRunning) return;
        renderRecipeModal();
        elements.recipeModal.classList.remove('hidden');
    }

    function closeRecipeModal() {
        elements.recipeModal.classList.add('hidden');
    }
    
    function startCooking(recipeId) {
        if (!state.gameRunning) return;
        const recipe = getRecipe(recipeId);
        if (!recipe) return;

        // Check if all ingredients are on the counter
        const availableCounterNames = state.counterIngredients.map(i => i.name);
        let canCook = true;
        
        // Find the indices of the ingredients to be consumed
        const consumedIndices = [];
        const tempCounter = [...state.counterIngredients];

        recipe.ingredients.forEach(required => {
            const indexInTemp = tempCounter.findIndex(item => item.name === required);
            if (indexInTemp === -1) {
                canCook = false;
            } else {
                consumedIndices.push(state.counterIngredients.findIndex(item => item.id === tempCounter[indexInTemp].id));
                tempCounter.splice(indexInTemp, 1); // Remove from temp to prevent double use
            }
        });


        if (!canCook) {
            alertMessage("Missing Ingredients!", `You need to place all ingredients for ${recipe.name} onto the prep counter first.`, 'red');
            return;
        }

        // Consume ingredients from the counter
        // Sort indices descendingly to splice correctly
        consumedIndices.sort((a, b) => b - a).forEach(index => {
            state.counterIngredients.splice(index, 1);
        });

        // Start the cooking process
        state.cooking.push({
            id: uuid(),
            recipeId: recipe.id,
            recipeName: recipe.name,
            cookTimer: recipe.time,
            maxTime: recipe.time,
            quality: 0.0,
        });
        
        renderCounterIngredients();
        renderCookingStation();
        closeRecipeModal();
        alertMessage("Cooking Started", `${recipe.name} is on the stove!`, 'green');
    }

    function plateDish(dishId) {
        if (!state.gameRunning) return;
        const index = state.cooking.findIndex(d => d.id === dishId);
        const dish = state.cooking[index];
        if (!dish) return;
        
        // Dish is finished, move to plated dishes (ready to serve)
        state.dishes.push({
            id: uuid(),
            recipeId: dish.recipeId,
            recipeName: dish.recipeName,
            quality: dish.quality,
        });
        
        state.totalQualityScore += dish.quality;
        state.cooking.splice(index, 1); // Remove from cooking station

        renderCookingStation();
        renderPlatedDishes();
        alertMessage("Dish Plated!", `${dish.recipeName} moved to The Pass. Quality: ${(dish.quality * 100).toFixed(0)}%.`, dish.quality >= 0.8 ? 'green' : (dish.quality >= 0.4 ? 'yellow' : 'red'));
    }

    // Serving Actions
    function serveDish(dishId, orderId) {
        if (!state.gameRunning) return;
        
        const dishIndex = state.dishes.findIndex(d => d.id === dishId);
        const dish = state.dishes[dishIndex];

        const orderIndex = state.customers.findIndex(c => c.orderId === orderId);
        const order = state.customers[orderIndex];

        if (!dish || !order || dish.recipeId !== order.recipeId) {
             alertMessage("Server Error", "Dish or Order mismatch.", 'red');
             return;
        }
        
        const recipe = getRecipe(dish.recipeId);
        
        // 1. Process Order Fulfillment
        const timeRemaining = order.timer;
        const earlyBonus = timeRemaining > 0 ? Math.round(timeRemaining) : 0;
        
        state.servedEarlyBonus += earlyBonus;
        state.customersServed += 1;
        state.money += recipe.price;
        
        // 2. Remove items from state
        state.dishes.splice(dishIndex, 1);
        state.customers.splice(orderIndex, 1);
        
        // 3. Re-render
        renderCustomers();
        renderPlatedDishes();

        let message = `${recipe.name} served to Customer #${order.orderId}! Earned $${recipe.price}.`;
        if (earlyBonus > 0) message += ` (+${earlyBonus}s early bonus!)`;
        
        alertMessage("Order Complete!", message, 'green');
        
        // Check for new order immediately after serving an existing one
        generateNewOrder();
    }

    // --- Rendering Functions ---

    function renderCustomers() {
        // Clear all slots
        for (let i = 1; i <= MAX_CUSTOMER_SLOTS; i++) {
            const slotEl = document.getElementById(`slot-${i}`);
            if (slotEl) slotEl.innerHTML = '';
        }
        
        // Populate occupied slots
        state.customers.forEach(customer => {
            const slotEl = document.getElementById(`slot-${customer.slot}`);
            if (!slotEl) return;
            
            const recipe = getRecipe(customer.recipeId);
            const patienceRatio = customer.timer / customer.maxTime;
            let icon = customer.emoji;
            let moodClass = '';
            let indicator = 'üü¢';
            let tagColor = 'bg-green-500';

            if (patienceRatio < 0.25) {
                icon = 'üò°';
                moodClass = 'customer-angry text-red-600';
                indicator = 'üî¥';
                tagColor = 'bg-red-500';
            } else if (patienceRatio < 0.5) {
                icon = 'üò†';
                moodClass = 'text-orange-500';
                indicator = 'üü†';
                tagColor = 'bg-orange-500';
            } else if (patienceRatio < 0.75) {
                icon = 'üòê';
                moodClass = 'text-yellow-600';
                indicator = 'üü°';
                tagColor = 'bg-yellow-500';
            }

            const percent = (customer.timer / customer.maxTime) * 100;

            slotEl.innerHTML = `
                <div class="customer-icon ${moodClass}">${icon}</div>
                <div class="customer-order-tag ${tagColor} text-white">#${customer.orderId}: ${recipe.name.split(' ')[0]}</div>
                <div class="w-full h-2 bg-gray-200 rounded-full my-1">
                    <div class="h-2 rounded-full ${tagColor}" style="width: ${percent}%;"></div>
                </div>
                <p class="text-xs font-semibold text-gray-700">${formatTime(Math.round(customer.timer))}</p>
            `;
        });
    }

    function renderInventory() {
        let html = '';
        const items = Object.entries(state.inventory).filter(([name, count]) => count > 0);
        
        if (items.length === 0) {
            elements.inventoryDisplay.innerHTML = '<p class="text-gray-400">Inventory: Empty</p>';
            return;
        }

        items.forEach(([name, count]) => {
            html += `
                <div class="bg-gray-700 rounded-md p-1.5 text-center text-xs font-semibold flex items-center shadow-md">
                    <span class="capitalize text-yellow-500 mr-2">${name}</span>
                    <span class="text-xs bg-gray-500 text-white rounded-full h-4 w-4 flex items-center justify-center">${count}</span>
                    <button onclick="placeIngredientOnCounter('${name}')" class="ml-2 px-2 py-0.5 bg-yellow-600 text-xs text-white rounded hover:bg-yellow-700 font-bold">
                        Prep
                    </button>
                </div>
            `;
        });
        elements.inventoryDisplay.innerHTML = html;
    }

    function renderCounterIngredients() {
        let html = '';
        state.counterIngredients.forEach((item) => {
            const isCritical = item.spoilageTimer <= 10;
            const spoilagePercent = (item.spoilageTimer / MOUSE_SPOILAGE_TIME) * 100;
            
            // Use static border color change instead of continuous animation
            const criticalClass = isCritical ? 'border-red-500 border-2 shadow-lg' : 'border-gray-200 border'; 

            html += `
                <div class="item-slot ${criticalClass}">
                    <div class="flex justify-between items-center text-xs font-bold mb-1">
                        <span class="capitalize text-gray-800">${item.name}</span>
                        <button onclick="removeIngredientFromCounter('${item.id}')" class="text-red-500 hover:text-red-700 font-bold ml-2 text-sm">‚Ü©Ô∏è</button>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${spoilagePercent}%; background-color: ${isCritical ? '#ef4444' : '#60a5fa'};"></div>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Mouse Risk: ${item.spoilageTimer}s</p>
                </div>
            `;
        });

        elements.counterIngredients.innerHTML = html;
    }

    function renderCookingStation() {
        let html = '';
        
        // 1. Currently cooking dishes
        state.cooking.forEach((dish) => {
            const percent = (dish.cookTimer / dish.maxTime) * 100;
            const qualityPercent = dish.quality * 100;
            let qualityClass = 'bg-gray-400';
            if (dish.quality >= 0.8) qualityClass = 'bg-green-500';
            else if (dish.quality >= 0.4) qualityClass = 'bg-yellow-500';
            else if (dish.cookTimer <= 0) qualityClass = 'bg-red-500';
            
            const isBurned = dish.cookTimer <= 0;

            html += `
                <div class="bg-white p-3 rounded-lg border-2 border-orange-400 shadow-md">
                    <div class="flex justify-between items-center mb-1">
                        <h3 class="font-bold text-base text-gray-800">${dish.recipeName}</h3>
                        <span class="text-xs font-semibold text-gray-500">Time: ${formatTime(Math.max(0, dish.cookTimer))}</span>
                    </div>
                    
                    <div class="progress-bar mb-2">
                        <div class="progress-fill bg-orange-500" style="width: ${100 - percent}%;"></div>
                    </div>
                    
                    <div class="flex justify-between items-center text-xs font-medium mb-2">
                        <span>Quality: ${(dish.quality * 100).toFixed(0)}%</span>
                        <div class="w-1/2 progress-bar">
                            <div class="progress-fill ${qualityClass}" style="width: ${qualityPercent}%;"></div>
                        </div>
                    </div>

                    <button onclick="plateDish('${dish.id}')" 
                            ${isBurned ? 'disabled' : ''}
                            class="w-full font-bold py-1 rounded transition duration-150 text-sm ${isBurned 
                                ? 'bg-gray-400 text-gray-600 cursor-not-allowed' 
                                : 'bg-red-600 hover:bg-red-700 text-white'
                            }">
                        ${isBurned ? 'BURNED (Trash)' : 'Plate & Send to Pass'}
                    </button>
                </div>
            `;
        });

        if (!html) {
             elements.cookingStation.innerHTML = '<p class="text-gray-500 text-sm italic col-span-2">Start a recipe to use a station.</p>';
        } else {
            elements.cookingStation.innerHTML = html;
        }
    }
    
    function renderPlatedDishes() {
        let html = '';
        if (state.dishes.length === 0) {
            elements.platedDishes.innerHTML = '<p class="text-yellow-200 text-sm">Plated food goes here...</p>';
            return;
        }
        
        state.dishes.forEach(dish => {
            const recipe = getRecipe(dish.recipeId);
            const qualityText = (dish.quality * 100).toFixed(0) + '%';
            
            // Find a matching pending order
            const matchingOrder = state.customers.find(c => c.recipeId === dish.recipeId);
            
            html += `
                <div onclick="${matchingOrder ? `serveDish('${dish.id}', ${matchingOrder.orderId})` : 'alertMessage(\'Ready to Serve\', \'No customer has ordered this dish yet!\', \'yellow\')'}" 
                     title="Click to Serve: ${recipe.name} (${qualityText})"
                     class="plated-dish ${matchingOrder ? 'bg-green-400 border-green-700' : 'bg-yellow-400 border-yellow-700'}">
                    <span class="text-xl">${recipe.name.slice(-2)}</span>
                    <span class="block text-xs font-bold text-gray-800 mt-1">${qualityText}</span>
                    ${matchingOrder ? `<span class="absolute top-0 right-0 text-red-700 text-xs font-bold bg-white rounded-full h-4 w-4 flex items-center justify-center">!</span>` : ''}
                </div>
            `;
        });
        
        elements.platedDishes.innerHTML = html;
    }


    function renderStockroomModal() {
        let html = '';
        STOCKROOM_ITEMS.forEach(item => {
            const currentStock = state.stockroomStock[item.name] || 0;
            const canGather = currentStock > 0;
            const canBuy = state.money >= item.cost;
            
            html += `
                <div class="bg-gray-50 p-3 rounded-lg text-center shadow border border-gray-300">
                    <p class="font-bold capitalize mb-1">${item.label}</p>
                    <p class="text-sm text-gray-700">Stock: <span class="font-bold ${currentStock > 0 ? 'text-green-600' : 'text-red-600'}">${currentStock}</span></p>
                    <p class="text-xs text-gray-600 mb-2">Gather Cost: ${item.time}s</p>
                    
                    <button 
                        onclick="gatherIngredient('${item.name}', ${item.time})" 
                        ${canGather ? '' : 'disabled'}
                        class="w-full font-bold py-1 rounded transition duration-150 text-sm mb-2 btn-game ${canGather ? 'bg-blue-500 hover:bg-blue-600 text-white' : 'bg-gray-400 text-gray-600 cursor-not-allowed'}">
                        Gather (x1)
                    </button>
                    
                    <button 
                        onclick="buyStock('${item.name}', ${item.cost})" 
                        ${canBuy ? '' : 'disabled'}
                        class="w-full font-bold py-1 rounded transition duration-150 text-xs btn-game ${canBuy ? 'bg-yellow-500 hover:bg-yellow-600 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}">
                        Buy Stock ($${item.cost})
                    </button>
                </div>
            `;
        });
        elements.stockroomInventory.innerHTML = html;
    }

    function renderRecipeModal() {
        let html = '';
        RECIPES.forEach(recipe => {
            const counterNames = state.counterIngredients.map(i => i.name);
            // Check if every ingredient required by the recipe is present AT LEAST once on the counter
            const hasAllIngredients = recipe.ingredients.every(ing => counterNames.includes(ing));

            const ingredientsHtml = recipe.ingredients.map(ing => {
                const available = counterNames.includes(ing);
                return `<span class="px-2 py-0.5 text-xs rounded-full ${available ? 'bg-green-200 text-green-800' : 'bg-red-200 text-red-800'}">${ing}</span>`;
            }).join(' ');

            html += `
                <div class="bg-gray-50 p-4 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-xl font-bold mb-2 text-gray-700">${recipe.name} (Time: ${recipe.time}s)</h3>
                    <p class="text-sm mb-3">Ingredients: ${ingredientsHtml}</p>
                    <button 
                        onclick="startCooking('${recipe.id}');" 
                        ${hasAllIngredients ? '' : 'disabled'}
                        class="w-full font-bold py-2 px-4 rounded-lg transition duration-150 btn-game ${hasAllIngredients 
                            ? 'bg-green-600 hover:bg-green-700 text-white' 
                            : 'bg-gray-400 text-gray-600 cursor-not-allowed'
                        }">
                        Start Cooking
                    </button>
                    ${!hasAllIngredients ? '<p class="text-xs text-red-500 mt-1">Place all ingredients on the counter first.</p>' : ''}
                </div>
            `;
        });
        elements.recipesList.innerHTML = html;
    }
    
    // Custom Alert Message (No native alert())
    function alertMessage(title, message, type = 'info') {
        let color, icon;
        switch (type) {
            case 'green': color = 'bg-green-600'; icon = '‚úÖ'; break;
            case 'red': color = 'bg-red-600'; icon = '‚ùå'; break;
            case 'yellow': color = 'bg-yellow-500'; icon = '‚ö†Ô∏è'; break;
            default: color = 'bg-blue-600'; icon = '‚ÑπÔ∏è';
        }

        const content = elements.customMessageContent;
        const modal = elements.customMessageModal;
        
        content.className = `bg-white rounded-xl p-6 w-full max-w-sm shadow-2xl text-center border-4 ${color.replace('bg-', 'border-')}`;
        content.innerHTML = `
            <span class="text-4xl block mb-2">${icon}</span>
            <h5 class="font-bold text-xl text-gray-800 mb-1">${title}</h5>
            <p class="text-sm text-gray-600 mb-4">${message}</p>
            <button onclick="closeMessageModal()" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-1 px-3 rounded text-sm btn-game">
                OK
            </button>
        `;
        
        modal.classList.remove('hidden');
    }
    
    // --- Start Game on Load ---
    window.onload = startGame;

</script>
</body>
</html>
